diff --git a/CMakeLists.txt b/CMakeLists.txt
index f997e4a..4813bc6 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -23,7 +23,7 @@ if(APPLE)
   message(STATUS "${_msg} - ${MACOSX_DEPLOYMENT_TARGET}")
 endif()
 
-project(Python C ASM)
+project(Python C CXX ASM)
 
 if(POLICY CMP0042)
     cmake_policy(SET CMP0042 OLD)
@@ -309,7 +310,7 @@
 
 # This is the major version number of Python
 set(LIBPYTHON_VERSION ${PY_VERSION_MAJOR}.${PY_VERSION_MINOR})
-if(WIN32)
+if(WIN32 AND OFF)
     set(LIBPYTHON_VERSION ${PY_VERSION_MAJOR}${PY_VERSION_MINOR})
 endif()
 set(LIBPYTHON python${LIBPYTHON_VERSION})
@@ -326,7 +327,7 @@
     set_property(GLOBAL PROPERTY FIND_LIBRARY_USE_LIB64_PATHS ON)
     set(LIBDIR "lib64")
 endif()
-set(PYTHONHOME "${LIBDIR}")
+set(PYTHONHOME "bin/python/Lib")
 if(UNIX)
     set(PYTHONHOME "${PYTHONHOME}/${LIBPYTHON}")
 endif()
@@ -350,7 +351,7 @@
     set(EXTENSION_INSTALL_DIR DLLs)
 endif()
 set(INCLUDE_INSTALL_DIR include/python${LD_VERSION})
-if(MSVC)
+if(MSVC AND OFF)
     set(INCLUDE_INSTALL_DIR include)
 endif()
 # Build tree directory
@@ -359,7 +360,7 @@
 set(EXTENSION_BUILD_DIR ${PROJECT_BINARY_DIR}/${PYTHONHOME}/lib-dynload)
 set(INCLUDE_BUILD_DIR ${SRC_DIR}/Include)
 
-set(ARCHIVEDIR "libs")      # Contains the static (*.a) and import libraries (*.lib)
+set(ARCHIVEDIR "lib")      # Contains the static (*.a) and import libraries (*.lib)
 
 # Directories specific to 'libpython'
 set(LIBPYTHON_LIBDIR ${LIBDIR})
@@ -396,6 +396,11 @@ if(INSTALL_DEVELOPMENT)
             COMPONENT Development)
 endif()
 
+add_definitions(
+    -D_CRT_SECURE_NO_DEPRECATE
+    -D_SCL_SECURE_NO_WARNINGS
+)
+
 # Set include directories
 include_directories(${INCLUDE_BUILD_DIR})
 include_directories(${PYCONFIG_BUILD_DIR})
@@ -459,7 +464,9 @@ add_subdirectory(cmake/extensions CMakeBuild/extensions)
 
 # Add the other subdirectories
 add_subdirectory(cmake/libpython CMakeBuild/libpython)
-add_subdirectory(cmake/python CMakeBuild/python)
+if (NOT WINDOWS_STORE)
+    add_subdirectory(cmake/python CMakeBuild/python)
+endif()
 add_subdirectory(cmake/include CMakeBuild/include)
 add_subdirectory(cmake/lib CMakeBuild/lib)
 if(BUILD_WININST)
@@ -467,7 +474,7 @@ if(BUILD_WININST)
 endif()
 
 # Add target to run "Argument Clinic" over all source files
-if(IS_PY3)
+if(IS_PY3 AND NOT WINDOWS_STORE)
 add_custom_target(clinic
     COMMAND ${CMAKE_CROSSCOMPILING_EMULATOR} $<TARGET_FILE:python> ${SRC_DIR}/Tools/clinic/clinic.py --make
     DEPENDS python
@@ -477,6 +484,7 @@ add_custom_target(clinic
 )
 endif()
 
+if(NOT WINDOWS_STORE)
 # Add target to generate 'Include/graminit.h' and 'Python/graminit.c'
 add_custom_target(generate_graminit
     COMMAND ${CMAKE_CROSSCOMPILING_EMULATOR} $<TARGET_FILE:pgen>
@@ -547,6 +555,7 @@ configure_file(
     ${PROJECT_BINARY_DIR}/${_asdl_subdir}/Parser/asdl.py
     COPYONLY
 )
+endif()
 
 show_extension_summary()
 
diff --git a/Modules/_ctypes/_ctypes.c b/Modules/_ctypes/_ctypes.c
index c5fc811..86647e3 100644
--- a/Modules/_ctypes/_ctypes.c
+++ b/Modules/_ctypes/_ctypes.c
@@ -102,11 +102,15 @@ bytes(cdata)
 #define PY_SSIZE_T_CLEAN
 
 #include "Python.h"
+#ifdef MS_WIN32
+#include <Windows.h>
+#endif
+
+#include "internal/pystate.h"
 #include "structmember.h"
 
 #include <ffi.h>
 #ifdef MS_WIN32
-#include <windows.h>
 #include <malloc.h>
 #ifndef IS_INTRESOURCE
 #define IS_INTRESOURCE(x) (((size_t)(x) >> 16) == 0)
diff --git a/Modules/_ctypes/callbacks.c b/Modules/_ctypes/callbacks.c
index ec9f443..f161f5d 100644
--- a/Modules/_ctypes/callbacks.c
+++ b/Modules/_ctypes/callbacks.c
@@ -136,7 +136,7 @@ static void _CallPythonObject(void *mem,
     PyObject *arglist = NULL;
     Py_ssize_t nArgs;
     PyObject *error_object = NULL;
-    int *space;
+    int *space = NULL;
     PyGILState_STATE state = PyGILState_Ensure();
 
     nArgs = PySequence_Length(converters);
diff --git a/Modules/_ctypes/callproc.c b/Modules/_ctypes/callproc.c
index ec596b4..8c6104d 100644
--- a/Modules/_ctypes/callproc.c
+++ b/Modules/_ctypes/callproc.c
@@ -769,7 +769,7 @@ static int _call_function_pointer(int flags,
 {
     PyThreadState *_save = NULL; /* For Py_BLOCK_THREADS and Py_UNBLOCK_THREADS */
     PyObject *error_object = NULL;
-    int *space;
+    int *space = NULL;
     ffi_cif cif;
     int cc;
 #ifdef MS_WIN32
@@ -985,6 +985,9 @@ error:
 static PyObject *
 GetComError(HRESULT errcode, GUID *riid, IUnknown *pIunk)
 {
+#ifdef MS_STORE
+    return Py_None;
+#else
     HRESULT hr;
     ISupportErrorInfo *psei = NULL;
     IErrorInfo *pei = NULL;
@@ -1048,6 +1051,7 @@ GetComError(HRESULT errcode, GUID *riid, IUnknown *pIunk)
         SysFreeString(source);
 
     return NULL;
+#endif
 }
 #endif
 
@@ -1801,6 +1805,12 @@ buffer_info(PyObject *self, PyObject *arg)
     return Py_BuildValue("siN", dict->format, dict->ndim, shape);
 }
 
+static PyObject *
+_kernel32_get_last_error(PyObject *self, PyObject *args)
+{
+    return PyLong_FromUnsignedLong(GetLastError());
+}
+
 PyMethodDef _ctypes_module_methods[] = {
     {"get_errno", get_errno, METH_NOARGS},
     {"set_errno", set_errno, METH_VARARGS},
@@ -1817,6 +1827,7 @@ PyMethodDef _ctypes_module_methods[] = {
     {"LoadLibrary", load_library, METH_VARARGS, load_library_doc},
     {"FreeLibrary", free_library, METH_VARARGS, free_library_doc},
     {"_check_HRESULT", check_hresult, METH_VARARGS},
+    {"GetLastError", _kernel32_get_last_error, METH_NOARGS },
 #else
     {"dlopen", py_dl_open, METH_VARARGS,
      "dlopen(name, flag={RTLD_GLOBAL|RTLD_LOCAL}) open a shared library"},
diff --git a/Modules/_elementtree.c b/Modules/_elementtree.c
index ff3a240..89a31b8 100644
--- a/Modules/_elementtree.c
+++ b/Modules/_elementtree.c
@@ -14,6 +14,7 @@
 #define PY_SSIZE_T_CLEAN
 
 #include "Python.h"
+#include "internal/pystate.h"
 #include "structmember.h"
 
 /* -------------------------------------------------------------------- */
diff --git a/Modules/_io/bufferedio.c b/Modules/_io/bufferedio.c
index 358a654..0d130b1 100644
--- a/Modules/_io/bufferedio.c
+++ b/Modules/_io/bufferedio.c
@@ -487,7 +487,7 @@ buffered_closed_get(buffered *self, void *context)
 static PyObject *
 buffered_close(buffered *self, PyObject *args)
 {
-    PyObject *res = NULL, *exc = NULL, *val, *tb;
+    PyObject *res = NULL, *exc = NULL, *val = NULL, *tb = NULL;
     int r;
 
     CHECK_INITIALIZED(self)
@@ -2227,7 +2227,7 @@ bufferedrwpair_writable(rwpair *self, PyObject *args)
 static PyObject *
 bufferedrwpair_close(rwpair *self, PyObject *args)
 {
-    PyObject *exc = NULL, *val, *tb;
+    PyObject *exc = NULL, *val = NULL, *tb = NULL;
     PyObject *ret = _forward_call(self->writer, &PyId_close, args);
     if (ret == NULL)
         PyErr_Fetch(&exc, &val, &tb);
diff --git a/Modules/_io/fileio.c b/Modules/_io/fileio.c
index 8bbe1ce..c867576 100644
--- a/Modules/_io/fileio.c
+++ b/Modules/_io/fileio.c
@@ -141,7 +141,7 @@ _io_FileIO_close_impl(fileio *self)
 /*[clinic end generated code: output=7737a319ef3bad0b input=f35231760d54a522]*/
 {
     PyObject *res;
-    PyObject *exc, *val, *tb;
+    PyObject *exc = NULL, *val = NULL, *tb = NULL;
     int rc;
     _Py_IDENTIFIER(close);
     res = _PyObject_CallMethodIdObjArgs((PyObject*)&PyRawIOBase_Type,
diff --git a/Modules/_io/textio.c b/Modules/_io/textio.c
index 9d0d9ca..3e085b4 100644
--- a/Modules/_io/textio.c
+++ b/Modules/_io/textio.c
@@ -2939,7 +2939,7 @@ _io_TextIOWrapper_close_impl(textio *self)
         Py_RETURN_NONE; /* stream already closed */
     }
     else {
-        PyObject *exc = NULL, *val, *tb;
+        PyObject *exc = NULL, *val = NULL, *tb = NULL;
         if (self->finalizing) {
             res = _PyObject_CallMethodIdObjArgs(self->buffer,
                                                 &PyId__dealloc_warn,
diff --git a/Modules/_io/winconsoleio.c b/Modules/_io/winconsoleio.c
index c11c1e0..37c9926 100644
--- a/Modules/_io/winconsoleio.c
+++ b/Modules/_io/winconsoleio.c
@@ -200,7 +200,7 @@ _io__WindowsConsoleIO_close_impl(winconsoleio *self)
 /*[clinic end generated code: output=27ef95b66c29057b input=185617e349ae4c7b]*/
 {
     PyObject *res;
-    PyObject *exc, *val, *tb;
+    PyObject *exc = NULL, *val = NULL, *tb = NULL;
     int rc;
     _Py_IDENTIFIER(close);
     res = _PyObject_CallMethodIdObjArgs((PyObject*)&PyRawIOBase_Type,
diff --git a/Modules/_localemodule.c b/Modules/_localemodule.c
index 8efda35..e2b7231 100644
--- a/Modules/_localemodule.c
+++ b/Modules/_localemodule.c
@@ -396,12 +396,12 @@ PyLocale_getdefaultlocale(PyObject* self)
 
     PyOS_snprintf(encoding, sizeof(encoding), "cp%d", GetACP());
 
-    if (GetLocaleInfo(LOCALE_USER_DEFAULT,
+    if (GetLocaleInfoA(LOCALE_USER_DEFAULT,
                       LOCALE_SISO639LANGNAME,
                       locale, sizeof(locale))) {
         Py_ssize_t i = strlen(locale);
         locale[i++] = '_';
-        if (GetLocaleInfo(LOCALE_USER_DEFAULT,
+        if (GetLocaleInfoA(LOCALE_USER_DEFAULT,
                           LOCALE_SISO3166CTRYNAME,
                           locale+i, (int)(sizeof(locale)-i)))
             return Py_BuildValue("ss", locale, encoding);
@@ -413,7 +413,7 @@ PyLocale_getdefaultlocale(PyObject* self)
 
     locale[0] = '0';
     locale[1] = 'x';
-    if (GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_IDEFAULTLANGUAGE,
+    if (GetLocaleInfoA(LOCALE_USER_DEFAULT, LOCALE_IDEFAULTLANGUAGE,
                       locale+2, sizeof(locale)-2)) {
         return Py_BuildValue("ss", locale, encoding);
     }
diff --git a/Modules/_pickle.c b/Modules/_pickle.c
index 60ef921..13ebb80 100644
--- a/Modules/_pickle.c
+++ b/Modules/_pickle.c
@@ -26,6 +26,10 @@ enum {
     DEFAULT_PROTOCOL = 3
 };
 
+#ifdef UNICODE
+#undef UNICODE
+#endif
+
 /* Pickle opcodes. These must be kept updated with pickle.py.
    Extensive docs are in pickletools.py. */
 enum opcode {
diff --git a/Modules/_winapi.c b/Modules/_winapi.c
index 9ea5a92..ecc65e2 100644
--- a/Modules/_winapi.c
+++ b/Modules/_winapi.c
@@ -70,10 +70,15 @@ check_CancelIoEx()
 {
     if (has_CancelIoEx == -1)
     {
+#ifdef MS_STORE
+        has_CancelIoEx = 1;
+        Py_CancelIoEx = CancelIoEx;
+#else
         HINSTANCE hKernel32 = GetModuleHandle("KERNEL32");
         * (FARPROC *) &Py_CancelIoEx = GetProcAddress(hKernel32,
                                                       "CancelIoEx");
         has_CancelIoEx = (Py_CancelIoEx != NULL);
+#endif
     }
     return has_CancelIoEx;
 }
@@ -451,7 +456,7 @@ _winapi_CreateFile_impl(PyObject *module, LPCTSTR file_name,
     HANDLE handle;
 
     Py_BEGIN_ALLOW_THREADS
-    handle = CreateFile(file_name, desired_access,
+    handle = CreateFileW(file_name, desired_access,
                         share_mode, security_attributes,
                         creation_disposition,
                         flags_and_attributes, template_file);
@@ -859,6 +867,8 @@ cleanup:
     return ret;
 }
 
+#ifndef MS_STORE
+
 typedef struct {
     LPPROC_THREAD_ATTRIBUTE_LIST attribute_list;
     LPHANDLE handle_list;
@@ -969,6 +979,7 @@ cleanup:
 
     return ret;
 }
+#endif // !MS_STORE
 
 /*[clinic input]
 _winapi.CreateProcess
@@ -1004,20 +1015,20 @@ _winapi_CreateProcess_impl(PyObject *module, Py_UNICODE *application_name,
     PyObject *ret = NULL;
     BOOL result;
     PROCESS_INFORMATION pi;
-    STARTUPINFOEXW si;
+    STARTUPINFOW si;
     PyObject *environment = NULL;
     wchar_t *wenvironment;
-    AttributeList attribute_list = {0};
+    //AttributeList attribute_list = {0};
 
     ZeroMemory(&si, sizeof(si));
-    si.StartupInfo.cb = sizeof(si);
+    si.cb = sizeof(si);
 
     /* note: we only support a small subset of all SI attributes */
-    si.StartupInfo.dwFlags = getulong(startup_info, "dwFlags");
-    si.StartupInfo.wShowWindow = (WORD)getulong(startup_info, "wShowWindow");
-    si.StartupInfo.hStdInput = gethandle(startup_info, "hStdInput");
-    si.StartupInfo.hStdOutput = gethandle(startup_info, "hStdOutput");
-    si.StartupInfo.hStdError = gethandle(startup_info, "hStdError");
+    si.dwFlags = getulong(startup_info, "dwFlags");
+    si.wShowWindow = (WORD)getulong(startup_info, "wShowWindow");
+    si.hStdInput = gethandle(startup_info, "hStdInput");
+    si.hStdOutput = gethandle(startup_info, "hStdOutput");
+    si.hStdError = gethandle(startup_info, "hStdError");
     if (PyErr_Occurred())
         goto cleanup;
 
@@ -1037,10 +1048,10 @@ _winapi_CreateProcess_impl(PyObject *module, Py_UNICODE *application_name,
         wenvironment = NULL;
     }
 
-    if (getattributelist(startup_info, "lpAttributeList", &attribute_list) < 0)
+    /*if (getattributelist(startup_info, "lpAttributeList", &attribute_list) < 0)
         goto cleanup;
 
-    si.lpAttributeList = attribute_list.attribute_list;
+    si.lpAttributeList = attribute_list.attribute_list;*/
 
     Py_BEGIN_ALLOW_THREADS
     result = CreateProcessW(application_name,
@@ -1048,7 +1059,7 @@ _winapi_CreateProcess_impl(PyObject *module, Py_UNICODE *application_name,
                            NULL,
                            NULL,
                            inherit_handles,
-                           creation_flags | EXTENDED_STARTUPINFO_PRESENT |
+                           creation_flags |
                            CREATE_UNICODE_ENVIRONMENT,
                            wenvironment,
                            current_directory,
@@ -1069,7 +1080,7 @@ _winapi_CreateProcess_impl(PyObject *module, Py_UNICODE *application_name,
 
 cleanup:
     Py_XDECREF(environment);
-    freeattributelist(&attribute_list);
+    //freeattributelist(&attribute_list);
 
     return ret;
 }
@@ -1141,7 +1152,7 @@ _winapi_ExitProcess_impl(PyObject *module, UINT ExitCode)
         _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_DEBUG);
     #endif
 
-    ExitProcess(ExitCode);
+    _exit(ExitCode);
 
     return NULL;
 }
@@ -1796,8 +1809,8 @@ PyInit__winapi(void)
     WINAPI_CONSTANT(F_DWORD, PIPE_WAIT);
     WINAPI_CONSTANT(F_DWORD, PROCESS_ALL_ACCESS);
     WINAPI_CONSTANT(F_DWORD, PROCESS_DUP_HANDLE);
-    WINAPI_CONSTANT(F_DWORD, STARTF_USESHOWWINDOW);
-    WINAPI_CONSTANT(F_DWORD, STARTF_USESTDHANDLES);
+    WINAPI_CONSTANT(F_DWORD, 0x00000001 /*STARTF_USESHOWWINDOW*/);
+    WINAPI_CONSTANT(F_DWORD, 0x00000100 /*STARTF_USESTDHANDLES*/);
     WINAPI_CONSTANT(F_DWORD, STD_INPUT_HANDLE);
     WINAPI_CONSTANT(F_DWORD, STD_OUTPUT_HANDLE);
     WINAPI_CONSTANT(F_DWORD, STD_ERROR_HANDLE);
diff --git a/Modules/atexitmodule.c b/Modules/atexitmodule.c
index afa1cfa..30dcbbf 100644
--- a/Modules/atexitmodule.c
+++ b/Modules/atexitmodule.c
@@ -65,7 +65,7 @@ atexit_cleanup(atexitmodule_state *modstate)
 static void
 atexit_callfuncs(PyObject *module)
 {
-    PyObject *exc_type = NULL, *exc_value, *exc_tb, *r;
+    PyObject *exc_type = NULL, *exc_value = NULL, *exc_tb = NULL, *r;
     atexit_callback *cb;
     atexitmodule_state *modstate;
     int i;
diff --git a/Modules/expat/loadlibrary.c b/Modules/expat/loadlibrary.c
index 35fdf98..fe224e9 100644
--- a/Modules/expat/loadlibrary.c
+++ b/Modules/expat/loadlibrary.c
@@ -79,6 +79,7 @@ typedef HMODULE (APIENTRY *LOADLIBRARYEX_FN)(LPCTSTR, HANDLE, DWORD);
 HMODULE _Expat_LoadLibrary(LPCTSTR filename)
 {
   HMODULE hModule = NULL;
+#if !defined(WINAPI_FAMILY) || WINAPI_FAMILY != WINAPI_FAMILY_APP
   LOADLIBRARYEX_FN pLoadLibraryEx = NULL;
 
   /* Get a handle to kernel32 so we can access it's functions at runtime */
@@ -130,7 +131,9 @@ HMODULE _Expat_LoadLibrary(LPCTSTR filename)
       free(path);
     }
   }
-
+#else
+  hModule = LoadPackagedLibrary(filename, 0);
+#endif
   return hModule;
 }
 
diff --git a/Modules/faulthandler.c b/Modules/faulthandler.c
index cf24c9b..616f1df 100644
--- a/Modules/faulthandler.c
+++ b/Modules/faulthandler.c
@@ -471,7 +471,7 @@ faulthandler_enable(void)
         handler->enabled = 1;
     }
 
-#ifdef MS_WINDOWS
+#if defined(MS_WINDOWS) && !defined(MS_STORE)
     assert(fatal_error.exc_handler == NULL);
     fatal_error.exc_handler = AddVectoredExceptionHandler(1, faulthandler_exc_handler);
 #endif
@@ -523,7 +523,7 @@ faulthandler_disable(void)
             faulthandler_disable_fatal_handler(handler);
         }
     }
-#ifdef MS_WINDOWS
+#if defined(MS_WINDOWS) && !defined(MS_STORE)
     if (fatal_error.exc_handler != NULL) {
         RemoveVectoredExceptionHandler(fatal_error.exc_handler);
         fatal_error.exc_handler = NULL;
@@ -924,8 +924,8 @@ faulthandler_suppress_crash_report(void)
     UINT mode;
 
     /* Configure Windows to not display the Windows Error Reporting dialog */
-    mode = SetErrorMode(SEM_NOGPFAULTERRORBOX);
-    SetErrorMode(mode | SEM_NOGPFAULTERRORBOX);
+    mode = SetErrorMode(0x0002 /*SEM_NOGPFAULTERRORBOX*/);
+    SetErrorMode(mode | 0x0002 /*SEM_NOGPFAULTERRORBOX*/);
 #endif
 
 #ifdef HAVE_SYS_RESOURCE_H
diff --git a/Modules/mmapmodule.c b/Modules/mmapmodule.c
index f957e2c..dcbb1c7 100644
--- a/Modules/mmapmodule.c
+++ b/Modules/mmapmodule.c
@@ -408,19 +408,16 @@ mmap_size_method(mmap_object *self,
 
 #ifdef MS_WINDOWS
     if (self->file_handle != INVALID_HANDLE_VALUE) {
-        DWORD low,high;
+        LARGE_INTEGER apiSize;
         long long size;
-        low = GetFileSize(self->file_handle, &high);
-        if (low == INVALID_FILE_SIZE) {
+        if (GetFileSizeEx(self->file_handle, &apiSize) == INVALID_FILE_SIZE) {
             /* It might be that the function appears to have failed,
                when indeed its size equals INVALID_FILE_SIZE */
             DWORD error = GetLastError();
             if (error != NO_ERROR)
                 return PyErr_SetFromWindowsErr(error);
         }
-        if (!high && low < LONG_MAX)
-            return PyLong_FromLong((long)low);
-        size = (((long long)high)<<32) + low;
+        size = apiSize.QuadPart;
         return PyLong_FromLongLong(size);
     } else {
         return PyLong_FromSsize_t(self->size);
@@ -484,6 +481,12 @@ mmap_resize_method(mmap_object *self,
                        newSizeLow, &newSizeHigh, FILE_BEGIN);
         /* Change the size of the file */
         SetEndOfFile(self->file_handle);
+#ifdef _UNICODE
+        wchar_t _tagname[2048];
+        mbstowcs(_tagname, self->tagname, 2048);
+#else
+        char* _tagname = self->tagname;
+#endif
         /* Create another mapping object and remap the file view */
         self->map_handle = CreateFileMapping(
             self->file_handle,
@@ -491,7 +494,7 @@ mmap_resize_method(mmap_object *self,
             PAGE_READWRITE,
             0,
             0,
-            self->tagname);
+            _tagname);
         if (self->map_handle != NULL) {
             self->data = (char *) MapViewOfFile(self->map_handle,
                                                 FILE_MAP_WRITE,
@@ -1294,17 +1297,16 @@ new_mmap_object(PyTypeObject *type, PyObject *args, PyObject *kwdict)
             return NULL;
         }
         if (!map_size) {
-            DWORD low,high;
-            low = GetFileSize(fh, &high);
+            LARGE_INTEGER apiSize;
             /* low might just happen to have the value INVALID_FILE_SIZE;
                so we need to check the last error also. */
-            if (low == INVALID_FILE_SIZE &&
+            if (GetFileSizeEx(fh, &apiSize) == INVALID_FILE_SIZE &&
                 (dwErr = GetLastError()) != NO_ERROR) {
                 Py_DECREF(m_obj);
                 return PyErr_SetFromWindowsErr(dwErr);
             }
 
-            size = (((long long) high) << 32) + low;
+            size = apiSize.QuadPart;
             if (size == 0) {
                 PyErr_SetString(PyExc_ValueError,
                                 "cannot mmap an empty file");
@@ -1359,12 +1361,18 @@ new_mmap_object(PyTypeObject *type, PyObject *args, PyObject *kwdict)
     off_lo = (DWORD)(offset & 0xFFFFFFFF);
     /* For files, it would be sufficient to pass 0 as size.
        For anonymous maps, we have to pass the size explicitly. */
+#if defined(MS_STORE)
+    wchar_t _tagname[2048];
+    mbstowcs(_tagname, m_obj->tagname, 2048);
+#else
+    char* _tagname = m_obj->tagname;
+#endif
     m_obj->map_handle = CreateFileMapping(m_obj->file_handle,
                                           NULL,
                                           flProtect,
                                           size_hi,
                                           size_lo,
-                                          m_obj->tagname);
+                                          _tagname);
     if (m_obj->map_handle != NULL) {
         m_obj->data = (char *) MapViewOfFile(m_obj->map_handle,
                                              dwDesiredAccess,
diff --git a/Modules/posixmodule.c b/Modules/posixmodule.c
index 5403660..d7be6ec 100644
--- a/Modules/posixmodule.c
+++ b/Modules/posixmodule.c
@@ -162,15 +162,17 @@ corresponding Unix manual entries for more information on calls.");
 #include <process.h>
 #else
 #ifdef _MSC_VER         /* Microsoft compiler */
+#ifndef MS_STORE
 #define HAVE_GETPPID    1
 #define HAVE_GETLOGIN   1
 #define HAVE_SPAWNV     1
 #define HAVE_EXECV      1
 #define HAVE_WSPAWNV    1
 #define HAVE_WEXECV     1
+#define HAVE_CWAIT      1
+#endif
 #define HAVE_PIPE       1
 #define HAVE_SYSTEM     1
-#define HAVE_CWAIT      1
 #define HAVE_FSYNC      1
 #define fsync _commit
 #else
@@ -307,11 +309,13 @@ extern int lstat(const char *, struct stat *);
 #endif
 #include "osdefs.h"
 #include <malloc.h>
-#include <windows.h>
+#include <Windows.h>
 #include <shellapi.h>   /* for ShellExecute() */
 #include <lmcons.h>     /* for UNLEN */
+#ifndef MS_STORE
 #ifdef SE_CREATE_SYMBOLIC_LINK_NAME /* Available starting with Vista */
 #define HAVE_SYMLINK
+#endif
 static int win32_can_symlink = 0;
 #endif
 #endif /* _MSC_VER */
@@ -481,8 +485,9 @@ PyOS_AfterFork(void)
 #ifdef MS_WINDOWS
 /* defined in fileutils.c */
 PyAPI_FUNC(void) _Py_time_t_to_FILE_TIME(time_t, int, FILETIME *);
-PyAPI_FUNC(void) _Py_attribute_data_to_stat(BY_HANDLE_FILE_INFORMATION *,
-                                            ULONG, struct _Py_stat_struct *);
+void
+_Py_attribute_data_to_stat(FILE_ID_BOTH_DIR_INFO*, FILE_STANDARD_INFO*, FILE_ID_INFO*,
+                           ULONG reparse_tag, struct _Py_stat_struct *result);
 #endif
 
 #ifdef MS_WINDOWS
@@ -1263,7 +1268,7 @@ PyLong_FromPy_off_t(Py_off_t offset)
 #endif
 }
 
-#ifdef MS_WINDOWS
+#if defined(MS_WINDOWS)
 
 static int
 win32_get_reparse_tag(HANDLE reparse_point_handle, ULONG *reparse_tag)
@@ -1553,6 +1558,7 @@ win32_wchdir(LPCWSTR path)
 #define HAVE_STAT_NSEC 1
 #define HAVE_STRUCT_STAT_ST_FILE_ATTRIBUTES 1
 
+#ifndef MS_STORE
 static void
 find_data_to_file_info(WIN32_FIND_DATAW *pFileData,
                        BY_HANDLE_FILE_INFORMATION *info,
@@ -1584,6 +1590,42 @@ attributes_from_dir(LPCWSTR pszFile, BY_HANDLE_FILE_INFORMATION *info, ULONG *re
     find_data_to_file_info(&FileData, info, reparse_tag);
     return TRUE;
 }
+#else
+static void
+find_data_to_file_info(WIN32_FIND_DATAW *pFileData,
+                       FILE_ID_BOTH_DIR_INFO* info, FILE_STANDARD_INFO* sInfo,
+                       ULONG *reparse_tag)
+{
+    memset(info, 0, sizeof(*info));
+    info->FileAttributes = pFileData->dwFileAttributes;
+    info->CreationTime.HighPart   = pFileData->ftCreationTime.dwHighDateTime;
+    info->CreationTime.LowPart   = pFileData->ftCreationTime.dwLowDateTime;
+    info->LastAccessTime.HighPart = pFileData->ftLastAccessTime.dwHighDateTime;
+    info->LastAccessTime.LowPart = pFileData->ftLastAccessTime.dwLowDateTime;
+    info->LastWriteTime.HighPart  = pFileData->ftLastWriteTime.dwHighDateTime;
+    info->LastWriteTime.LowPart  = pFileData->ftLastWriteTime.dwLowDateTime;
+    info->EndOfFile.HighPart = pFileData->nFileSizeHigh;
+    info->EndOfFile.LowPart = pFileData->nFileSizeLow;
+/*  info->nNumberOfLinks   = 1; */
+    if (pFileData->dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)
+        *reparse_tag = pFileData->dwReserved0;
+    else
+        *reparse_tag = 0;
+}
+
+static BOOL
+attributes_from_dir(LPCWSTR pszFile, FILE_ID_BOTH_DIR_INFO* info, FILE_STANDARD_INFO* sInfo, ULONG *reparse_tag)
+{
+    HANDLE hFindFile;
+    WIN32_FIND_DATAW FileData;
+    hFindFile = FindFirstFileW(pszFile, &FileData);
+    if (hFindFile == INVALID_HANDLE_VALUE)
+        return FALSE;
+    FindClose(hFindFile);
+    find_data_to_file_info(&FileData, info, sInfo, reparse_tag);
+    return TRUE;
+}
+#endif
 
 static BOOL
 get_target_path(HANDLE hdl, wchar_t **target_path)
@@ -1629,7 +1671,9 @@ win32_xstat_impl(const wchar_t *path, struct _Py_stat_struct *result,
 {
     int code;
     HANDLE hFile, hFile2;
-    BY_HANDLE_FILE_INFORMATION info;
+    FILE_ID_BOTH_DIR_INFO info;
+    FILE_STANDARD_INFO sInfo;
+    FILE_ID_INFO idInfo;
     ULONG reparse_tag = 0;
     wchar_t *target_path;
     const wchar_t *dot;
@@ -1658,10 +1702,10 @@ win32_xstat_impl(const wchar_t *path, struct _Py_stat_struct *result,
             return -1;
         /* Could not get attributes on open file. Fall back to
            reading the directory. */
-        if (!attributes_from_dir(path, &info, &reparse_tag))
+        if (!attributes_from_dir(path, &info, &sInfo, &reparse_tag))
             /* Very strange. This should not fail now */
             return -1;
-        if (info.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {
+        if (info.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {
             if (traverse) {
                 /* Should traverse, but could not open reparse point handle */
                 SetLastError(lastError);
@@ -1669,11 +1713,13 @@ win32_xstat_impl(const wchar_t *path, struct _Py_stat_struct *result,
             }
         }
     } else {
-        if (!GetFileInformationByHandle(hFile, &info)) {
+        if (!GetFileInformationByHandleEx(hFile, FileIdBothDirectoryInfo, &info, sizeof(info)) ||
+            !GetFileInformationByHandleEx(hFile, FileStandardInfo, &sInfo, sizeof(sInfo)) ||
+            !GetFileInformationByHandleEx(hFile, FileIdInfo, &idInfo, sizeof(idInfo))) {
             CloseHandle(hFile);
             return -1;
         }
-        if (info.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {
+        if (info.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {
             if (!win32_get_reparse_tag(hFile, &reparse_tag))
                 return -1;
             /* Close the outer open file handle now that we're about to
@@ -1703,7 +1750,7 @@ win32_xstat_impl(const wchar_t *path, struct _Py_stat_struct *result,
         } else
             CloseHandle(hFile);
     }
-    _Py_attribute_data_to_stat(&info, reparse_tag, result);
+    _Py_attribute_data_to_stat(&info, &sInfo, &idInfo, reparse_tag, result);
 
     /* Set S_IEXEC if it is an .exe, .bat, ... */
     dot = wcsrchr(path, '.');
@@ -3305,7 +3352,7 @@ posix_getcwd(int use_bytes)
 
         buf = tmpbuf;
 #ifdef MS_WINDOWS
-        cwd = getcwd(buf, (int)buflen);
+        cwd = _getcwd(buf, (int)buflen);
 #else
         cwd = getcwd(buf, buflen);
 #endif
@@ -3355,7 +3402,7 @@ os_getcwdb_impl(PyObject *module)
 }
 
 
-#if ((!defined(HAVE_LINK)) && defined(MS_WINDOWS))
+#if ((!defined(HAVE_LINK)) && defined(MS_WINDOWS)) && !defined(MS_STORE)
 #define HAVE_LINK 1
 #endif
 
@@ -3838,6 +3885,9 @@ os__getvolumepathname_impl(PyObject *module, path_t *path)
 /*[clinic end generated code: output=804c63fd13a1330b input=722b40565fa21552]*/
 {
     PyObject *result;
+#ifdef MS_STORE
+    result = PyUnicode_FromString("");
+#else
     wchar_t *mountpath=NULL;
     size_t buflen;
     BOOL ret;
@@ -3869,6 +3919,7 @@ os__getvolumepathname_impl(PyObject *module, path_t *path)
 
 exit:
     PyMem_Free(mountpath);
+#endif
     return result;
 }
 
@@ -10743,10 +10794,11 @@ static HINSTANCE (CALLBACK *Py_ShellExecuteW)(HWND, LPCWSTR, LPCWSTR, LPCWSTR,
 static int
 check_ShellExecute()
 {
-    HINSTANCE hShell32;
+    HINSTANCE hShell32 = NULL;
 
     /* only recheck */
     if (-1 == has_ShellExecute) {
+#ifndef MS_STORE
         Py_BEGIN_ALLOW_THREADS
         /* Security note: this call is not vulnerable to "DLL hijacking".
            SHELL32 is part of "KnownDLLs" and so Windows always load
@@ -10754,6 +10806,7 @@ check_ShellExecute()
            in the DLL search path. */
         hShell32 = LoadLibraryW(L"SHELL32");
         Py_END_ALLOW_THREADS
+#endif
         if (hShell32) {
             *(FARPROC*)&Py_ShellExecuteW = GetProcAddress(hShell32,
                                             "ShellExecuteW");
@@ -11370,6 +11423,7 @@ os_cpu_count_impl(PyObject *module)
 {
     int ncpu = 0;
 #ifdef MS_WINDOWS
+#ifndef MS_STORE
     /* Vista is supported and the GetMaximumProcessorCount API is Win7+
        Need to fallback to Vista behavior if this call isn't present */
     HINSTANCE hKernel32;
@@ -11381,7 +11435,9 @@ os_cpu_count_impl(PyObject *module)
     if (_GetMaximumProcessorCount != NULL) {
         ncpu = _GetMaximumProcessorCount(ALL_PROCESSOR_GROUPS);
     }
-    else {
+    else
+#endif
+    {
         SYSTEM_INFO sysinfo;
         GetSystemInfo(&sysinfo);
         ncpu = sysinfo.dwNumberOfProcessors;
@@ -11467,6 +11523,9 @@ static int
 os_get_handle_inheritable_impl(PyObject *module, intptr_t handle)
 /*[clinic end generated code: output=36be5afca6ea84d8 input=cfe99f9c05c70ad1]*/
 {
+#ifdef MS_STORE
+    return 0;
+#else
     DWORD flags;
 
     if (!GetHandleInformation((HANDLE)handle, &flags)) {
@@ -11475,6 +11534,7 @@ os_get_handle_inheritable_impl(PyObject *module, intptr_t handle)
     }
 
     return flags & HANDLE_FLAG_INHERIT;
+#endif
 }
 
 
@@ -11492,11 +11552,13 @@ os_set_handle_inheritable_impl(PyObject *module, intptr_t handle,
                                int inheritable)
 /*[clinic end generated code: output=021d74fe6c96baa3 input=7a7641390d8364fc]*/
 {
+#ifndef MS_STORE
     DWORD flags = inheritable ? HANDLE_FLAG_INHERIT : 0;
     if (!SetHandleInformation((HANDLE)handle, HANDLE_FLAG_INHERIT, flags)) {
         PyErr_SetFromWindowsErr(0);
         return NULL;
     }
+#endif
     Py_RETURN_NONE;
 }
 #endif /* MS_WINDOWS */
@@ -11953,7 +12015,9 @@ static PyObject *
 DirEntry_from_find_data(path_t *path, WIN32_FIND_DATAW *dataW)
 {
     DirEntry *entry;
-    BY_HANDLE_FILE_INFORMATION file_info;
+    FILE_ID_BOTH_DIR_INFO info;
+    FILE_STANDARD_INFO sInfo;
+    FILE_ID_INFO idInfo;
     ULONG reparse_tag;
     wchar_t *joined_path;
 
@@ -11989,8 +12053,8 @@ DirEntry_from_find_data(path_t *path, WIN32_FIND_DATAW *dataW)
             goto error;
     }
 
-    find_data_to_file_info(dataW, &file_info, &reparse_tag);
-    _Py_attribute_data_to_stat(&file_info, reparse_tag, &entry->win32_lstat);
+    find_data_to_file_info(dataW, &info, &sInfo, &reparse_tag);
+    _Py_attribute_data_to_stat(&info, &sInfo, &idInfo, reparse_tag, &entry->win32_lstat);
 
     return (PyObject *)entry;
 
@@ -12636,7 +12700,7 @@ static PyMethodDef posix_methods[] = {
                         METH_VARARGS | METH_KEYWORDS,
                         readlink__doc__},
 #endif /* HAVE_READLINK */
-#if !defined(HAVE_READLINK) && defined(MS_WINDOWS)
+#if !defined(HAVE_READLINK) && defined(MS_WINDOWS)
     {"readlink",        (PyCFunction)win_readlink,
                         METH_VARARGS | METH_KEYWORDS,
                         readlink__doc__},
diff --git a/Modules/selectmodule.c b/Modules/selectmodule.c
index 93d896a..a6327e1 100644
--- a/Modules/selectmodule.c
+++ b/Modules/selectmodule.c
@@ -53,7 +53,7 @@ extern void bzero(void *, int);
 
 #ifdef MS_WINDOWS
 #  define WIN32_LEAN_AND_MEAN
-#  include <winsock.h>
+#  include <WinSock2.h>
 #else
 #  define SOCKET int
 #endif
diff --git a/Modules/socketmodule.c b/Modules/socketmodule.c
index e6d3f8b..fac0aa6 100644
--- a/Modules/socketmodule.c
+++ b/Modules/socketmodule.c
@@ -323,6 +323,7 @@ static FlagRuntimeInfo win_runtime_flags[] = {
     {14393, "TCP_FASTOPEN"}
 };
 
+#ifndef MS_STORE
 static void
 remove_unusable_flags(PyObject *m)
 {
@@ -372,7 +373,7 @@ remove_unusable_flags(PyObject *m)
         }
     }
 }
-
+#endif
 #endif
 
 #include <stddef.h>
@@ -2539,11 +2540,13 @@ sock_accept(PySocketSockObject *s)
     newfd = ctx.result;
 
 #ifdef MS_WINDOWS
+#ifndef MS_STORE
     if (!SetHandleInformation((HANDLE)newfd, HANDLE_FLAG_INHERIT, 0)) {
         PyErr_SetFromWindowsErr(0);
         SOCKETCLOSE(newfd);
         goto finally;
     }
+#endif // !MS_STORE
 #else
 
 #if defined(HAVE_ACCEPT4) && defined(SOCK_CLOEXEC)
@@ -5023,7 +5026,7 @@ sock_initobj(PyObject *self, PyObject *args, PyObject *kwds)
             set_error();
             return -1;
         }
-
+#ifndef MS_STORE
         if (!support_wsa_no_inherit) {
             if (!SetHandleInformation((HANDLE)fd, HANDLE_FLAG_INHERIT, 0)) {
                 closesocket(fd);
@@ -5031,6 +5034,7 @@ sock_initobj(PyObject *self, PyObject *args, PyObject *kwds)
                 return -1;
             }
         }
+#endif
 #else
         /* UNIX */
         Py_BEGIN_ALLOW_THREADS
@@ -5141,10 +5145,24 @@ socket_gethostname(PyObject *self, PyObject *unused)
     /* Don't use winsock's gethostname, as this returns the ANSI
        version of the hostname, whereas we need a Unicode string.
        Otherwise, gethostname apparently also returns the DNS name. */
+    DWORD size;
+    PyObject *result;
+
+#ifdef MS_STORE
+#define MAX_HOSTNAME_CHARS 256
+    wchar_t name[MAX_HOSTNAME_CHARS];
+
+    size = Py_ARRAY_LENGTH(name);
+    if (SOCKET_ERROR == GetHostNameW(name, size))
+    {
+      return PyErr_SetFromWindowsErr(WSAGetLastError());
+    }
+
+    size = wcsnlen_s(name, size);
+#else
     wchar_t buf[MAX_COMPUTERNAME_LENGTH + 1];
-    DWORD size = Py_ARRAY_LENGTH(buf);
     wchar_t *name;
-    PyObject *result;
+    size = Py_ARRAY_LENGTH(buf);
 
     if (GetComputerNameExW(ComputerNamePhysicalDnsHostname, buf, &size))
         return PyUnicode_FromWideChar(buf, size);
@@ -5169,9 +5187,11 @@ socket_gethostname(PyObject *self, PyObject *unused)
         PyMem_Free(name);
         return PyErr_SetFromWindowsErr(0);
     }
-
+#endif
     result = PyUnicode_FromWideChar(name, size);
+#ifndef MS_STORE
     PyMem_Free(name);
+#endif
     return result;
 #else
     char buf[1024];
@@ -5705,12 +5725,13 @@ socket_dup(PyObject *self, PyObject *fdobj)
                       &info, 0, WSA_FLAG_OVERLAPPED);
     if (newfd == INVALID_SOCKET)
         return set_error();
-
+#ifndef MS_STORE
     if (!SetHandleInformation((HANDLE)newfd, HANDLE_FLAG_INHERIT, 0)) {
         closesocket(newfd);
         PyErr_SetFromWindowsErr(0);
         return NULL;
     }
+#endif
 #else
     /* On UNIX, dup can be used to duplicate the file descriptor of a socket */
     newfd = _Py_dup(fd);
@@ -6775,7 +6796,11 @@ PyInit__socket(void)
 
 #ifdef MS_WINDOWS
     if (support_wsa_no_inherit == -1) {
+#ifdef MS_STORE
+        support_wsa_no_inherit = 1;
+#else
         support_wsa_no_inherit = IsWindows7SP1OrGreater();
+#endif // MS_STORE
     }
 #endif
 
@@ -7968,7 +7993,7 @@ PyInit__socket(void)
     netdb_lock = PyThread_allocate_lock();
 #endif
 
-#ifdef MS_WINDOWS
+#if defined(MS_WINDOWS) && !defined(MS_STORE)
     /* remove some flags on older version Windows during run-time */
     remove_unusable_flags(m);
 #endif
diff --git a/Modules/timemodule.c b/Modules/timemodule.c
index 13a174a..0f841a3 100644
--- a/Modules/timemodule.c
+++ b/Modules/timemodule.c
@@ -1546,7 +1546,9 @@ init_timezone(PyObject *m)
      */
 #if defined(HAVE_TZNAME) && !defined(__GLIBC__) && !defined(__CYGWIN__)
     PyObject *otz0, *otz1;
+#if !defined(MS_STORE)
     tzset();
+#endif
     PyModule_AddIntConstant(m, "timezone", timezone);
 #ifdef HAVE_ALTZONE
     PyModule_AddIntConstant(m, "altzone", altzone);
diff --git a/PC/clinic/msvcrtmodule.c.h b/PC/clinic/msvcrtmodule.c.h
index 22ddfea..2385209 100644
--- a/PC/clinic/msvcrtmodule.c.h
+++ b/PC/clinic/msvcrtmodule.c.h
@@ -171,6 +171,8 @@ exit:
     return return_value;
 }
 
+#if !defined(MS_STORE)
+
 PyDoc_STRVAR(msvcrt_kbhit__doc__,
 "kbhit($module, /)\n"
 "--\n"
@@ -413,6 +415,8 @@ exit:
     return return_value;
 }
 
+#endif // !defined(MS_STORE
+
 #if defined(_DEBUG)
 
 PyDoc_STRVAR(msvcrt_CrtSetReportFile__doc__,
diff --git a/PC/getpathp.c b/PC/getpathp.c
index 1b553d5..255db42 100644
--- a/PC/getpathp.c
+++ b/PC/getpathp.c
@@ -241,9 +241,17 @@ typedef HRESULT(__stdcall *PPathCchCombineEx) (PWSTR pszPathOut, size_t cchPathO
                                                unsigned long dwFlags);
 static PPathCchCombineEx _PathCchCombineEx;
 
+#ifdef MS_STORE
+#include <pathcch.h>
+#endif
+
 static void
 join(wchar_t *buffer, const wchar_t *stuff)
 {
+#ifdef MS_STORE
+    _PathCchCombineEx = PathCchCombineEx;
+    _PathCchCombineEx_Initialized = 1;
+#else
     if (_PathCchCombineEx_Initialized == 0) {
         HMODULE pathapi = LoadLibraryW(L"api-ms-win-core-path-l1-1-0.dll");
         if (pathapi) {
@@ -254,16 +262,19 @@ join(wchar_t *buffer, const wchar_t *stuff)
         }
         _PathCchCombineEx_Initialized = 1;
     }
-
+#endif
     if (_PathCchCombineEx) {
         if (FAILED(_PathCchCombineEx(buffer, MAXPATHLEN+1, buffer, stuff, 0))) {
             Py_FatalError("buffer overflow in getpathp.c's join()");
         }
-    } else {
+    }
+#ifndef MS_STORE
+    else {
         if (!PathCombineW(buffer, buffer, stuff)) {
             Py_FatalError("buffer overflow in getpathp.c's join()");
         }
     }
+#endif
 }
 
 static int _PathCchCanonicalizeEx_Initialized = 0;
@@ -276,7 +287,10 @@ static _PyInitError canonicalize(wchar_t *buffer, const wchar_t *path)
     if (buffer == NULL) {
         return _Py_INIT_NO_MEMORY();
     }
-
+#ifdef MS_STORE
+    _PathCchCanonicalizeEx = PathCchCanonicalizeEx;
+    _PathCchCanonicalizeEx_Initialized = 1;
+#else
     if (_PathCchCanonicalizeEx_Initialized == 0) {
         HMODULE pathapi = LoadLibraryW(L"api-ms-win-core-path-l1-1-0.dll");
         if (pathapi) {
@@ -287,17 +301,19 @@ static _PyInitError canonicalize(wchar_t *buffer, const wchar_t *path)
         }
         _PathCchCanonicalizeEx_Initialized = 1;
     }
-
+#endif
     if (_PathCchCanonicalizeEx) {
         if (FAILED(_PathCchCanonicalizeEx(buffer, MAXPATHLEN + 1, path, 0))) {
             return _Py_INIT_ERR("buffer overflow in getpathp.c's canonicalize()");
         }
     }
+#ifndef MS_STORE
     else {
         if (!PathCanonicalizeW(buffer, path)) {
             return _Py_INIT_ERR("buffer overflow in getpathp.c's canonicalize()");
         }
     }
+#endif
     return _Py_INIT_OK();
 }
 
@@ -334,7 +350,7 @@ search_for_prefix(wchar_t *prefix, const wchar_t *argv0_path, const wchar_t *lan
     return 0;
 }
 
-
+#ifndef MS_STORE
 #ifdef Py_ENABLE_SHARED
 
 /* a string loaded from the DLL at startup.*/
@@ -505,7 +521,7 @@ done:
     return retval;
 }
 #endif /* Py_ENABLE_SHARED */
-
+#endif
 
 static _PyInitError
 get_dll_path(PyCalculatePath *calculate, _PyPathConfig *config)
@@ -773,7 +789,7 @@ calculate_module_search_path(const _PyCoreConfig *core_config,
                              wchar_t *prefix)
 {
     int skiphome = calculate->home==NULL ? 0 : 1;
-#ifdef Py_ENABLE_SHARED
+#if defined(Py_ENABLE_SHARED) && !defined(MS_STORE)
     calculate->machine_path = getpythonregpath(HKEY_LOCAL_MACHINE, skiphome);
     calculate->user_path = getpythonregpath(HKEY_CURRENT_USER, skiphome);
 #endif
@@ -1045,6 +1061,7 @@ static HANDLE hPython3;
 int
 _Py_CheckPython3(void)
 {
+#ifndef MS_STORE
     wchar_t py3path[MAXPATHLEN+1];
     wchar_t *s;
     if (python3_checked) {
@@ -1069,5 +1086,11 @@ _Py_CheckPython3(void)
     wcscpy(py3path, Py_GetPrefix());
     wcscat(py3path, L"\\DLLs\\python3.dll");
     hPython3 = LoadLibraryExW(py3path, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
+#else
+    hPython3 = LoadLibraryW(L"python3.dll");
+    if (hPython3 != NULL) {
+        return 1;
+    }
+#endif
     return hPython3 != NULL;
 }
diff --git a/PC/msvcrtmodule.c b/PC/msvcrtmodule.c
index c4113e5..51797ab 100644
--- a/PC/msvcrtmodule.c
+++ b/PC/msvcrtmodule.c
@@ -210,6 +210,8 @@ msvcrt_get_osfhandle_impl(PyObject *module, int fd)
     return (HANDLE)handle;
 }
 
+#if !defined(MS_STORE)
+
 /* Console I/O */
 /*[clinic input]
 msvcrt.kbhit -> long
@@ -393,6 +395,8 @@ msvcrt_ungetwch_impl(PyObject *module, int unicode_char)
     Py_RETURN_NONE;
 }
 
+#endif
+
 #ifdef _DEBUG
 /*[clinic input]
 msvcrt.CrtSetReportFile -> HANDLE
@@ -503,6 +507,7 @@ static struct PyMethodDef msvcrt_functions[] = {
     MSVCRT_SETMODE_METHODDEF
     MSVCRT_OPEN_OSFHANDLE_METHODDEF
     MSVCRT_GET_OSFHANDLE_METHODDEF
+#ifndef MS_STORE
     MSVCRT_KBHIT_METHODDEF
     MSVCRT_GETCH_METHODDEF
     MSVCRT_GETCHE_METHODDEF
@@ -516,6 +521,7 @@ static struct PyMethodDef msvcrt_functions[] = {
     MSVCRT_GETWCHE_METHODDEF
     MSVCRT_PUTWCH_METHODDEF
     MSVCRT_UNGETWCH_METHODDEF
+#endif
     {NULL,                      NULL}
 };
 
@@ -576,10 +582,10 @@ PyInit_msvcrt(void)
     insertint(d, "LK_NBRLCK", _LK_NBRLCK);
     insertint(d, "LK_RLCK", _LK_RLCK);
     insertint(d, "LK_UNLCK", _LK_UNLCK);
-    insertint(d, "SEM_FAILCRITICALERRORS", SEM_FAILCRITICALERRORS);
-    insertint(d, "SEM_NOALIGNMENTFAULTEXCEPT", SEM_NOALIGNMENTFAULTEXCEPT);
-    insertint(d, "SEM_NOGPFAULTERRORBOX", SEM_NOGPFAULTERRORBOX);
-    insertint(d, "SEM_NOOPENFILEERRORBOX", SEM_NOOPENFILEERRORBOX);
+    insertint(d, "SEM_FAILCRITICALERRORS", 0x0001 /*SEM_FAILCRITICALERRORS*/);
+    insertint(d, "SEM_NOALIGNMENTFAULTEXCEPT", 0x0004 /*SEM_NOALIGNMENTFAULTEXCEPT*/);
+    insertint(d, "SEM_NOGPFAULTERRORBOX", 0x0002 /*SEM_NOGPFAULTERRORBOX*/);
+    insertint(d, "SEM_NOOPENFILEERRORBOX", 0x8000 /*SEM_NOOPENFILEERRORBOX*/);
 #ifdef _DEBUG
     insertint(d, "CRT_WARN", _CRT_WARN);
     insertint(d, "CRT_ERROR", _CRT_ERROR);
diff --git a/PC/pyconfig.h b/PC/pyconfig.h
index d2a3f5d..26b91dc 100644
--- a/PC/pyconfig.h
+++ b/PC/pyconfig.h
@@ -67,6 +67,20 @@ WIN32 is still required for the locale module.
 
 #define MS_WIN32 /* only support win32 and greater. */
 #define MS_WINDOWS
+#ifdef WINAPI_FAMILY
+#   include <sdkddkver.h>
+#   include <winapifamily.h>
+#   if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)
+#     ifndef MS_STORE
+#       define MS_STORE
+#       include "winrt.h"
+#       define MS_PLATFORM "win10"
+#     endif
+#   endif
+#endif
+#ifndef MS_PLATFORM
+#define MS_PLATFORM "win32"
+#endif // !MS_PLATFORM
 #ifndef PYTHONPATH
 #       define PYTHONPATH L".\\DLLs;.\\lib"
 #endif
@@ -133,8 +147,13 @@ WIN32 is still required for the locale module.
 
 /* set the version macros for the windows headers */
 /* Python 3.5+ requires Windows Vista or greater */
+#ifdef MS_STORE
+#define Py_WINVER WDK_NTDDI_VERSION
+#define Py_NTDDI WDK_NTDDI_VERSION
+#else
 #define Py_WINVER 0x0600 /* _WIN32_WINNT_VISTA */
 #define Py_NTDDI NTDDI_VISTA
+#endif
 
 /* We only set these values when building Python - we don't want to force
    these values on extensions, as that will affect the prototypes and
@@ -298,7 +317,7 @@ Py_NO_ENABLE_SHARED to find out.  Also support MS_NO_COREDLL for b/w compat */
 /* maintain "win32" sys.platform for backward compatibility of Python code,
    the Win64 API should be close enough to the Win32 API to make this
    preferable */
-#       define PLATFORM "win32"
+#       define PLATFORM MS_PLATFORM
 #       define SIZEOF_VOID_P 8
 #       define SIZEOF_TIME_T 8
 #       define SIZEOF_OFF_T 4
@@ -312,7 +331,7 @@ Py_NO_ENABLE_SHARED to find out.  Also support MS_NO_COREDLL for b/w compat */
    should define this. */
 #       define HAVE_LARGEFILE_SUPPORT
 #elif defined(MS_WIN32)
-#       define PLATFORM "win32"
+#       define PLATFORM MS_PLATFORM
 #       define HAVE_LARGEFILE_SUPPORT
 #       define SIZEOF_VOID_P 4
 #       define SIZEOF_OFF_T 4
@@ -467,7 +486,9 @@ Py_NO_ENABLE_SHARED to find out.  Also support MS_NO_COREDLL for b/w compat */
 /* #define HAVE_ALTZONE */
 
 /* Define if you have the putenv function.  */
+#ifndef MS_STORE
 #define HAVE_PUTENV
+#endif
 
 /* Define if your compiler supports function prototypes */
 #define HAVE_PROTOTYPES
diff --git a/PC/winrt.cpp b/PC/winrt.cpp
new file mode 100644
index 0000000..632a821
--- /dev/null
+++ b/PC/winrt.cpp
@@ -0,0 +1,153 @@
+
+#include "Python.h"
+
+#if defined(MS_STORE)
+#define WIN32_LEAN_AND_MEAN
+#include <Windows.h>
+#include <roapi.h>
+#include <Windows.ApplicationModel.h>
+#include <windows.system.profile.h>
+
+unsigned long long ABIGetVersion()
+{
+  using ABI::Windows::System::Profile::IAnalyticsVersionInfo;
+
+  unsigned long long result = 0;
+  if (SUCCEEDED(RoInitialize(RO_INIT_MULTITHREADED)))
+  {
+    HSTRING_HEADER analytics_version_info_object_header = { };
+    HSTRING analytics_version_info_name_object = nullptr;
+    IAnalyticsVersionInfo* pAnalyticsVersionInfo = nullptr;
+
+    if (SUCCEEDED(WindowsCreateStringReference(
+      RuntimeClass_Windows_System_Profile_AnalyticsVersionInfo,
+      static_cast<UINT32>(wcslen(RuntimeClass_Windows_System_Profile_AnalyticsVersionInfo)),
+      &analytics_version_info_object_header,
+      &analytics_version_info_name_object)))
+    {
+      if (SUCCEEDED(RoGetActivationFactory(
+        analytics_version_info_name_object,
+        IID_INS_ARGS(&pAnalyticsVersionInfo))))
+      {
+        HSTRING versionVal;
+        if (SUCCEEDED(pAnalyticsVersionInfo->get_DeviceFamilyVersion(&versionVal)))
+        {
+          const wchar_t* raw = WindowsGetStringRawBuffer(versionVal, nullptr);
+          wchar_t* end;
+          result = wcstoull(raw, &end, 10);
+        }
+      }
+    }
+
+    if (nullptr != pAnalyticsVersionInfo)
+      pAnalyticsVersionInfo->Release();
+
+    RoUninitialize();
+  }
+  return result;
+}
+
+size_t ABIGetInstallPath(wchar_t* path)
+{
+  using ABI::Windows::ApplicationModel::IPackage;
+  using ABI::Windows::Storage::IStorageFolder;
+  using ABI::Windows::Storage::IStorageItem;
+
+  size_t result = 0;
+  if (SUCCEEDED(RoInitialize(RO_INIT_MULTITHREADED)))
+  {
+    HSTRING_HEADER object_header = { };
+    HSTRING name_object = nullptr;
+    IPackage* pPackage = nullptr;
+    IStorageFolder* pInstalledFolder = nullptr;
+    IStorageItem* pstorageItem = nullptr;
+
+    if (SUCCEEDED(WindowsCreateStringReference(
+      RuntimeClass_Windows_ApplicationModel_Package,
+      static_cast<UINT32>(wcslen(RuntimeClass_Windows_ApplicationModel_Package)),
+      &object_header, &name_object)))
+    {
+      if (SUCCEEDED(RoGetActivationFactory(name_object, IID_INS_ARGS(&pPackage))))
+      {
+        HSTRING installedPath;
+        if (SUCCEEDED(pPackage->get_InstalledLocation(&pInstalledFolder)) && 
+          SUCCEEDED(pInstalledFolder->QueryInterface(_uuidof(IStorageItem), reinterpret_cast<void**>(&pstorageItem))) &&
+          SUCCEEDED(pstorageItem->get_Path(&installedPath)))
+        {
+          const wchar_t* raw = WindowsGetStringRawBuffer(installedPath, nullptr);
+          result = wcslen(raw);
+          wcscpy_s(path, result, raw);
+        }
+      }
+    }
+
+    if (nullptr != pstorageItem)
+      pstorageItem->Release();
+
+    if (nullptr != pInstalledFolder)
+      pInstalledFolder->Release();
+
+    RoUninitialize();
+  }
+  return result;
+}
+
+#if __cplusplus
+extern "C" {
+#endif
+  void* LoadLibraryW(const wchar_t* lpFileName)
+  {
+    HINSTANCE hDLL = NULL;
+    wchar_t packagepath[MAX_PATH];
+
+    size_t len = ABIGetInstallPath(packagepath);
+    if (len >= 0 && wcsnicmp(packagepath, lpFileName, len) == 0)
+    {
+      if (lpFileName[len] == '\\' || lpFileName[len] == '/')
+        len++;
+      hDLL = LoadPackagedLibrary(&lpFileName[len], 0);
+    }
+    else
+    {
+      hDLL = LoadPackagedLibrary(lpFileName, 0);
+    }
+    return hDLL;
+  }
+
+  void* LoadLibraryExW(const wchar_t* lpFileName, void* hFile, unsigned long dwFlags)
+  {
+    return LoadLibraryW(lpFileName);
+  }
+
+  HANDLE CreateFileW(LPCWSTR lpFileName,
+    DWORD dwDesiredAccess,
+    DWORD dwShareMode,
+    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
+    DWORD dwCreationDisposition,
+    DWORD dwFlagsAndAttributes,
+    HANDLE hTemplateFile)
+  {
+    CREATEFILE2_EXTENDED_PARAMETERS createExParams;
+    createExParams.dwSize = sizeof(CREATEFILE2_EXTENDED_PARAMETERS);
+    createExParams.dwFileAttributes = dwFlagsAndAttributes & 0xFFFF;
+    createExParams.dwFileFlags = dwFlagsAndAttributes & 0xFFF00000;
+    createExParams.dwSecurityQosFlags = dwFlagsAndAttributes & 0x000F00000;
+    createExParams.lpSecurityAttributes = lpSecurityAttributes;
+    createExParams.hTemplateFile = hTemplateFile;
+    return CreateFile2(lpFileName, dwDesiredAccess, dwShareMode, dwCreationDisposition, &createExParams);
+  }
+
+  unsigned long getpid()
+  {
+    return GetCurrentProcessId();
+  }
+
+  unsigned long GetVersion()
+  {
+    return static_cast<long>(ABIGetVersion() >> 32);
+  }
+#if __cplusplus
+} //extern C
+#endif
+
+#endif /*defined(MS_STORE)*/
diff --git a/PC/winrt.h b/PC/winrt.h
new file mode 100644
index 0000000..53abe5b
--- /dev/null
+++ b/PC/winrt.h
@@ -0,0 +1,35 @@
+
+#pragma once
+
+#if defined(MS_STORE)
+# if !defined(NTDDI_WIN10_RS4) || (NTDDI_VERSION < NTDDI_WIN10_RS4)
+#  ifdef getenv
+#   undef getenv
+#  endif
+# define getenv winrt_getenv
+# endif
+
+#if __cplusplus
+extern "C" {
+#endif
+
+void* LoadLibraryExW(const wchar_t* lpFileName, void* hFile, unsigned long dwFlags);
+void* LoadLibraryW(const wchar_t* lpFileName);
+
+char* winrt_getenv(const char* varname);
+
+void* CreateFileW(const wchar_t* lpFileName,
+  unsigned long dwDesiredAccess,
+  unsigned long dwShareMode,
+  struct _SECURITY_ATTRIBUTES* lpSecurityAttributes,
+  unsigned long dwCreationDisposition,
+  unsigned long dwFlagsAndAttributes,
+  void* hTemplateFile);
+
+unsigned long getpid();
+
+unsigned long GetVersion();
+#if __cplusplus
+}
+#endif
+#endif
\ No newline at end of file
diff --git a/Python/bootstrap_hash.c b/Python/bootstrap_hash.c
index e2afba2..19753ab 100644
--- a/Python/bootstrap_hash.c
+++ b/Python/bootstrap_hash.c
@@ -1,6 +1,6 @@
 #include "Python.h"
 #ifdef MS_WINDOWS
-#  include <windows.h>
+#  include <Windows.h>
 /* All sample MSDN wincrypt programs include the header below. It is at least
  * required with Min GW. */
 #  include <wincrypt.h>
@@ -31,14 +31,15 @@ static int _Py_HashSecret_Initialized = 0;
 #endif
 
 #ifdef MS_WINDOWS
-static HCRYPTPROV hCryptProv = 0;
+#include <bcrypt.h>
+static BCRYPT_ALG_HANDLE hCryptProv = 0;
 
 static int
 win32_urandom_init(int raise)
 {
     /* Acquire context */
-    if (!CryptAcquireContext(&hCryptProv, NULL, NULL,
-                             PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
+    const NTSTATUS status = BCryptOpenAlgorithmProvider(&hCryptProv, BCRYPT_RNG_ALGORITHM, NULL, 0);
+    if (!BCRYPT_SUCCESS(status))
         goto error;
 
     return 0;
@@ -67,9 +68,10 @@ win32_urandom(unsigned char *buffer, Py_ssize_t size, int raise)
     while (size > 0)
     {
         chunk = size > INT_MAX ? INT_MAX : size;
-        if (!CryptGenRandom(hCryptProv, (DWORD)chunk, buffer))
+        const NTSTATUS status = BCryptGenRandom(hCryptProv, buffer, (ULONG)chunk, 0);
+        if (!BCRYPT_SUCCESS(status))
         {
-            /* CryptGenRandom() failed */
+            /* BCryptGenRandom() failed */
             if (raise) {
                 PyErr_SetFromWindowsErr(0);
             }
@@ -622,7 +624,7 @@ _Py_HashRandomization_Fini(void)
 {
 #ifdef MS_WINDOWS
     if (hCryptProv) {
-        CryptReleaseContext(hCryptProv, 0);
+        BCryptCloseAlgorithmProvider(hCryptProv, 0);
         hCryptProv = 0;
     }
 #else
diff --git a/Python/dynload_win.c b/Python/dynload_win.c
index 0fdf77f..d0b459a 100644
--- a/Python/dynload_win.c
+++ b/Python/dynload_win.c
@@ -210,7 +211,7 @@ dl_funcptr _PyImport_FindSharedFuncptrWindows(const char *prefix,
 #endif
 
         /* Don't display a message box when Python can't load a DLL */
-        old_mode = SetErrorMode(SEM_FAILCRITICALERRORS);
+        old_mode = SetErrorMode(0x0001 /*SEM_FAILCRITICALERRORS*/);
 
 #if HAVE_SXS
         cookie = _Py_ActivateActCtx();
@@ -219,7 +220,7 @@ dl_funcptr _PyImport_FindSharedFuncptrWindows(const char *prefix,
             in directory of pathname first. */
         /* XXX This call doesn't exist in Windows CE */
         hDLL = LoadLibraryExW(wpathname, NULL,
-                              LOAD_WITH_ALTERED_SEARCH_PATH);
+                              0x00000008 /*LOAD_WITH_ALTERED_SEARCH_PATH*/);
 #if HAVE_SXS
         _Py_DeactivateActCtx(cookie);
 #endif
diff --git a/Python/fileutils.c b/Python/fileutils.c
index 5e71d37..bf7a51c 100644
--- a/Python/fileutils.c
+++ b/Python/fileutils.c
@@ -46,12 +46,16 @@ _Py_device_encoding(int fd)
         Py_RETURN_NONE;
 
 #if defined(MS_WINDOWS)
+#if !defined(MS_STORE)
     if (fd == 0)
         cp = GetConsoleCP();
     else if (fd == 1 || fd == 2)
         cp = GetConsoleOutputCP();
     else
         cp = 0;
+#else
+    cp = GetACP();
+#endif
     /* GetConsoleCP() and GetConsoleOutputCP() return 0 if the application
        has no console */
     if (cp != 0)
@@ -772,27 +776,36 @@ attributes_to_mode(DWORD attr)
     return m;
 }
 
+static void
+longlong_to_time_t_nsec(LONGLONG in, time_t *time_out, int* nsec_out)
+{
+    *nsec_out = (int)(in % 10000000) * 100; /* FILETIME is in units of 100 nsec. */
+    *time_out = Py_SAFE_DOWNCAST((in / 10000000) - secs_between_epochs, __int64, time_t);
+}
+
 void
-_Py_attribute_data_to_stat(BY_HANDLE_FILE_INFORMATION *info, ULONG reparse_tag,
-                           struct _Py_stat_struct *result)
+_Py_attribute_data_to_stat(FILE_ID_BOTH_DIR_INFO* info, FILE_STANDARD_INFO* sInfo, FILE_ID_INFO* idInfo,
+                           ULONG reparse_tag, struct _Py_stat_struct *result)
 {
-    memset(result, 0, sizeof(*result));
-    result->st_mode = attributes_to_mode(info->dwFileAttributes);
-    result->st_size = (((__int64)info->nFileSizeHigh)<<32) + info->nFileSizeLow;
-    result->st_dev = info->dwVolumeSerialNumber;
-    result->st_rdev = result->st_dev;
-    FILE_TIME_to_time_t_nsec(&info->ftCreationTime, &result->st_ctime, &result->st_ctime_nsec);
-    FILE_TIME_to_time_t_nsec(&info->ftLastWriteTime, &result->st_mtime, &result->st_mtime_nsec);
-    FILE_TIME_to_time_t_nsec(&info->ftLastAccessTime, &result->st_atime, &result->st_atime_nsec);
-    result->st_nlink = info->nNumberOfLinks;
-    result->st_ino = (((uint64_t)info->nFileIndexHigh) << 32) + info->nFileIndexLow;
-    if (reparse_tag == IO_REPARSE_TAG_SYMLINK) {
-        /* first clear the S_IFMT bits */
-        result->st_mode ^= (result->st_mode & S_IFMT);
-        /* now set the bits that make this a symlink */
-        result->st_mode |= S_IFLNK;
-    }
-    result->st_file_attributes = info->dwFileAttributes;
+  memset(result, 0, sizeof(*result));
+  /* similar to stat() */
+  result->st_mode = attributes_to_mode(info->FileAttributes);
+  result->st_size = (__int64)info->EndOfFile.QuadPart;
+  longlong_to_time_t_nsec(info->CreationTime.QuadPart, &result->st_ctime, &result->st_ctime_nsec);
+  longlong_to_time_t_nsec(info->LastWriteTime.QuadPart, &result->st_mtime, &result->st_mtime_nsec);
+  longlong_to_time_t_nsec(info->LastAccessTime.QuadPart, &result->st_atime, &result->st_atime_nsec);
+  /* specific to fstat() */
+  result->st_nlink = sInfo->NumberOfLinks;
+  result->st_ino = info->FileIndex;
+  if (reparse_tag == IO_REPARSE_TAG_SYMLINK) {
+    /* first clear the S_IFMT bits */
+    result->st_mode ^= (result->st_mode & S_IFMT);
+    /* now set the bits that make this a symlink */
+    result->st_mode |= S_IFLNK;
+  }
+  result->st_file_attributes = info->FileAttributes;
+  result->st_ino = *(long long*)&idInfo->FileId;
+  result->st_dev = idInfo->VolumeSerialNumber;
 }
 #endif
 
@@ -812,7 +825,13 @@ int
 _Py_fstat_noraise(int fd, struct _Py_stat_struct *status)
 {
 #ifdef MS_WINDOWS
+#ifdef MS_STORE
+    FILE_ID_BOTH_DIR_INFO info;
+    FILE_STANDARD_INFO sInfo;
+    FILE_ID_INFO idInfo;
+#else
     BY_HANDLE_FILE_INFORMATION info;
+#endif
     HANDLE h;
     int type;
 
@@ -845,17 +864,13 @@ _Py_fstat_noraise(int fd, struct _Py_stat_struct *status)
             status->st_mode = _S_IFIFO;
         return 0;
     }
-
-    if (!GetFileInformationByHandle(h, &info)) {
-        /* The Win32 error is already set, but we also set errno for
-           callers who expect it */
-        errno = winerror_to_errno(GetLastError());
+    if (!GetFileInformationByHandleEx(h, FileIdBothDirectoryInfo, &info, sizeof(info)) ||
+      !GetFileInformationByHandleEx(h, FileStandardInfo, &sInfo, sizeof(sInfo)) ||
+      !GetFileInformationByHandleEx(h, FileIdInfo, &idInfo, sizeof(idInfo))) {
         return -1;
     }
 
-    _Py_attribute_data_to_stat(&info, 0, status);
-    /* specific to fstat() */
-    status->st_ino = (((uint64_t)info.nFileIndexHigh) << 32) + info.nFileIndexLow;
+    _Py_attribute_data_to_stat(&info, &sInfo, &idInfo, 0, status);
     return 0;
 #else
     return fstat(fd, status);
@@ -949,7 +964,6 @@ get_inheritable(int fd, int raise)
 {
 #ifdef MS_WINDOWS
     HANDLE handle;
-    DWORD flags;
 
     _Py_BEGIN_SUPPRESS_IPH
     handle = (HANDLE)_get_osfhandle(fd);
@@ -959,7 +973,10 @@ get_inheritable(int fd, int raise)
             PyErr_SetFromErrno(PyExc_OSError);
         return -1;
     }
-
+#ifdef MS_STORE
+    return 0;
+#else
+    DWORD flags;
     if (!GetHandleInformation(handle, &flags)) {
         if (raise)
             PyErr_SetFromWindowsErr(0);
@@ -967,6 +984,7 @@ get_inheritable(int fd, int raise)
     }
 
     return (flags & HANDLE_FLAG_INHERIT);
+#endif
 #else
     int flags;
 
@@ -995,8 +1013,6 @@ static int
 set_inheritable(int fd, int inheritable, int raise, int *atomic_flag_works)
 {
 #ifdef MS_WINDOWS
-    HANDLE handle;
-    DWORD flags;
 #else
 #if defined(HAVE_SYS_IOCTL_H) && defined(FIOCLEX) && defined(FIONCLEX)
     static int ioctl_works = -1;
@@ -1024,6 +1040,18 @@ set_inheritable(int fd, int inheritable, int raise, int *atomic_flag_works)
     }
 
 #ifdef MS_WINDOWS
+#ifdef MS_STORE
+    if (!inheritable) {
+      return 0;
+    }
+
+    if (raise) {
+      PyErr_SetString(PyExc_NotImplementedError, "Inheritable handles are not supported in UWP.");
+    }
+    return -1;
+#else
+    HANDLE handle;
+    DWORD flags;
     _Py_BEGIN_SUPPRESS_IPH
     handle = (HANDLE)_get_osfhandle(fd);
     _Py_END_SUPPRESS_IPH
@@ -1043,7 +1071,7 @@ set_inheritable(int fd, int inheritable, int raise, int *atomic_flag_works)
         return -1;
     }
     return 0;
-
+#endif
 #else
 
 #if defined(HAVE_SYS_IOCTL_H) && defined(FIOCLEX) && defined(FIONCLEX)
diff --git a/Python/pytime.c b/Python/pytime.c
index 0e94131..e98e421 100644
--- a/Python/pytime.c
+++ b/Python/pytime.c
@@ -1,6 +1,9 @@
 #include "Python.h"
 #ifdef MS_WINDOWS
 #include <windows.h>
+#ifdef MS_STORE
+#include <WinSock2.h>
+#endif
 #endif
 
 #if defined(__APPLE__)
@@ -666,11 +669,13 @@ pygettimeofday(_PyTime_t *tp, _Py_clock_info_t *info, int raise)
        days). */
     *tp = large.QuadPart * 100 - 11644473600000000000;
     if (info) {
+#if !defined(MS_STORE)
         DWORD timeAdjustment, timeIncrement;
         BOOL isTimeAdjustmentDisabled, ok;
-
+#endif
         info->implementation = "GetSystemTimeAsFileTime()";
         info->monotonic = 0;
+#if !defined(MS_STORE)
         ok = GetSystemTimeAdjustment(&timeAdjustment, &timeIncrement,
                                      &isTimeAdjustmentDisabled);
         if (!ok) {
@@ -678,6 +683,9 @@ pygettimeofday(_PyTime_t *tp, _Py_clock_info_t *info, int raise)
             return -1;
         }
         info->resolution = timeIncrement * 1e-7;
+#else
+        info->resolution = 1 * 1e-7;
+#endif
         info->adjustable = 1;
     }
 
@@ -785,10 +793,13 @@ pymonotonic(_PyTime_t *tp, _Py_clock_info_t *info, int raise)
     *tp = t * MS_TO_NS;
 
     if (info) {
+#if !defined(MS_STORE)
         DWORD timeAdjustment, timeIncrement;
         BOOL isTimeAdjustmentDisabled, ok;
+#endif
         info->implementation = "GetTickCount64()";
         info->monotonic = 1;
+#if !defined(MS_STORE)
         ok = GetSystemTimeAdjustment(&timeAdjustment, &timeIncrement,
                                      &isTimeAdjustmentDisabled);
         if (!ok) {
@@ -796,6 +807,9 @@ pymonotonic(_PyTime_t *tp, _Py_clock_info_t *info, int raise)
             return -1;
         }
         info->resolution = timeIncrement * 1e-7;
+#else
+        info->resolution = 1 * 1e-7;
+#endif
         info->adjustable = 0;
     }
 
diff --git a/Python/sysmodule.c b/Python/sysmodule.c
index efe5b29..04754e0 100644
--- a/Python/sysmodule.c
+++ b/Python/sysmodule.c
@@ -1067,10 +1067,6 @@ sys_getwindowsversion(PyObject *self)
     int pos = 0;
     OSVERSIONINFOEX ver;
     DWORD realMajor, realMinor, realBuild;
-    HANDLE hKernel32;
-    wchar_t kernel32_path[MAX_PATH];
-    LPVOID verblock;
-    DWORD verblock_size;
 
     ver.dwOSVersionInfoSize = sizeof(ver);
     if (!GetVersionEx((OSVERSIONINFO*) &ver))
@@ -1084,7 +1080,11 @@ sys_getwindowsversion(PyObject *self)
     PyStructSequence_SET_ITEM(version, pos++, PyLong_FromLong(ver.dwMinorVersion));
     PyStructSequence_SET_ITEM(version, pos++, PyLong_FromLong(ver.dwBuildNumber));
     PyStructSequence_SET_ITEM(version, pos++, PyLong_FromLong(ver.dwPlatformId));
+#if !defined(MS_STORE)
     PyStructSequence_SET_ITEM(version, pos++, PyUnicode_FromString(ver.szCSDVersion));
+#else
+    PyStructSequence_SET_ITEM(version, pos++, PyUnicode_FromWideChar(ver.szCSDVersion, -1));
+#endif
     PyStructSequence_SET_ITEM(version, pos++, PyLong_FromLong(ver.wServicePackMajor));
     PyStructSequence_SET_ITEM(version, pos++, PyLong_FromLong(ver.wServicePackMinor));
     PyStructSequence_SET_ITEM(version, pos++, PyLong_FromLong(ver.wSuiteMask));
@@ -1093,7 +1093,11 @@ sys_getwindowsversion(PyObject *self)
     realMajor = ver.dwMajorVersion;
     realMinor = ver.dwMinorVersion;
     realBuild = ver.dwBuildNumber;
-
+#if !defined(MS_STORE)
+    HANDLE hKernel32;
+    wchar_t kernel32_path[MAX_PATH];
+    LPVOID verblock;
+    DWORD verblock_size;
     // GetVersion will lie if we are running in a compatibility mode.
     // We need to read the version info from a system file resource
     // to accurately identify the OS version. If we fail for any reason,
@@ -1113,6 +1117,7 @@ sys_getwindowsversion(PyObject *self)
         }
         PyMem_RawFree(verblock);
     }
+#endif
     PyStructSequence_SET_ITEM(version, pos++, Py_BuildValue("(kkk)",
         realMajor,
         realMinor,
diff --git a/cmake/config_3.c.in b/cmake/config_3.c.in
index 7b2d3c7..2ac30b1 100644
--- a/cmake/config_3.c.in
+++ b/cmake/config_3.c.in
@@ -10,7 +10,7 @@ extern "C" {
 /* -- ADDMODULE MARKER 1 -- */
 
 extern PyObject* PyMarshal_Init(void);
-extern PyObject* PyInit_imp(void);
+extern PyObject* PyInit__imp(void);
 extern PyObject* PyInit_gc(void);
 extern PyObject* PyInit__ast(void);
 extern PyObject* _PyWarnings_Init(void);
@@ -35,7 +35,7 @@ struct _inittab _PyImport_Inittab[] = {
     {"marshal", PyMarshal_Init},
 
     /* This lives in import.c */
-    {"_imp", PyInit_imp},
+    {"_imp", PyInit__imp},
 
     /* This lives in Python/Python-ast.c */
     {"_ast", PyInit__ast},
diff --git a/cmake/extensions/CMakeLists.txt b/cmake/extensions/CMakeLists.txt
index 24d4b1f..8c8e1a8 100644
--- a/cmake/extensions/CMakeLists.txt
+++ b/cmake/extensions/CMakeLists.txt
@@ -105,11 +105,13 @@
 
 # Python3
 add_python_extension(atexit BUILTIN REQUIRES IS_PY3 SOURCES atexitmodule.c) # Register functions to be run at interpreter-shutdown
+add_python_extension(_blake2 REQUIRES IS_PY3 SOURCES _blake2/blake2b2s.py _blake2/blake2b_impl.c _blake2/blake2module.c _blake2/blake2s_impl.c)
 add_python_extension(_codecs BUILTIN REQUIRES IS_PY3 SOURCES _codecsmodule.c) # access to the builtin codecs and codec registry
 add_python_extension(faulthandler BUILTIN REQUIRES IS_PY3 SOURCES faulthandler.c)
 add_python_extension(_opcode BUILTIN REQUIRES IS_PY3 SOURCES _opcode.c)
 add_python_extension(_operator ${WIN32_BUILTIN} REQUIRES IS_PY3 SOURCES _operator.c)
 add_python_extension(_pickle BUILTIN REQUIRES IS_PY3 SOURCES _pickle.c)
+add_python_extension(_sha3 BUILTIN REQUIRES IS_PY3 SOURCES _sha3/sha3module.c)
 add_python_extension(_sre BUILTIN REQUIRES IS_PY3 SOURCES _sre.c) # Fredrik Lundh's new regular expressions
 add_python_extension(_stat BUILTIN REQUIRES IS_PY3 SOURCES _stat.c) # stat.h interface
 add_python_extension(_symtable BUILTIN REQUIRES IS_PY3 SOURCES symtablemodule.c)
@@ -182,9 +182,11 @@ add_python_extension(msvcrt REQUIRES MSVC BUILTIN SOURCES ${SRC_DIR}/PC/msvcrtmo
 add_python_extension(nt REQUIRES WIN32 BUILTIN SOURCES posixmodule.c)
 add_python_extension(_subprocess REQUIRES WIN32 IS_PY2 BUILTIN SOURCES ${SRC_DIR}/PC/_subprocess.c)
 
-set(winreg2_NAME _winreg)
-set(winreg3_NAME winreg)
-add_python_extension(${winreg${PY_VERSION_MAJOR}_NAME} REQUIRES WIN32 BUILTIN SOURCES ${SRC_DIR}/PC/${winreg${PY_VERSION_MAJOR}_NAME}.c)
+if (NOT WINDOWS_STORE)
+    set(winreg2_NAME _winreg)
+    set(winreg3_NAME winreg)
+    add_python_extension(${winreg${PY_VERSION_MAJOR}_NAME} REQUIRES WIN32 BUILTIN SOURCES ${SRC_DIR}/PC/${winreg${PY_VERSION_MAJOR}_NAME}.c)
+endif()
 
 # Python3: Windows-only extensions
 add_python_extension(_overlapped
@@ -221,6 +223,7 @@
         SOURCES _multiprocessing/multiprocessing.c
                 _multiprocessing/semaphore.c
                 ${_multiprocessing${PY_VERSION_MAJOR}_SOURCES}
+        REQUIRES WITH_THREAD
         LIBRARIES ws2_32
     )
 endif()
diff --git a/cmake/lib/CMakeLists.txt b/cmake/lib/CMakeLists.txt
index 82e8ec8..331fd6f 100644
--- a/cmake/lib/CMakeLists.txt
+++ b/cmake/lib/CMakeLists.txt
@@ -20,6 +20,8 @@ foreach(file ${libfiles})
 
     if(is_test AND (NOT BUILD_TESTING OR NOT INSTALL_TEST))
         set(include_file 0)
+    elseif(WINDOWS_STORE AND "${file}" MATCHES ".exe")
+        set(include_file 0)
     endif()
 
     if(include_file AND (NOT is_platform_file OR is_matching_platform_file))
diff --git a/cmake/libpython/CMakeLists.txt b/cmake/libpython/CMakeLists.txt
index 235d856..dd845ed 100644
--- a/cmake/libpython/CMakeLists.txt
+++ b/cmake/libpython/CMakeLists.txt
@@ -110,6 +110,7 @@ set(OBJECT_COMMON_SOURCES # Equivalent to OBJECT_OBJS in Makefile.pre
     ${SRC_DIR}/Objects/boolobject.c
     ${SRC_DIR}/Objects/bytearrayobject.c
     ${SRC_DIR}/Objects/bytes_methods.c
+    ${SRC_DIR}/Objects/call.c
     ${SRC_DIR}/Objects/capsule.c
     ${SRC_DIR}/Objects/cellobject.c
     ${SRC_DIR}/Objects/classobject.c
@@ -168,6 +169,12 @@ elseif(WIN32)
         ${SRC_DIR}/PC/dl_nt.c
         ${SRC_DIR}/Python/dynload_win.c
         )
+	if(WINDOWS_STORE)
+	    list(APPEND DYNLOAD_SOURCES
+		${SRC_DIR}/PC/winrt.cpp
+		${SRC_DIR}/PC/winrt.h
+		)
+	endif()
     set(ms_dll_id "${PY_VERSION_MAJOR}.${PY_VERSION_MINOR}")
     if(${CMAKE_SIZEOF_VOID_P} EQUAL 4)
       set(ms_dll_id "${ms_dll_id}-32")
@@ -198,8 +205,13 @@ if(WIN32)
 endif()
 
 set(PYTHON3_COMMON_SOURCES
+    ${SRC_DIR}/Python/ast_opt.c
+    ${SRC_DIR}/Python/ast_unparse.c
     ${SRC_DIR}/Python/dynamic_annotations.c
+    ${SRC_DIR}/Python/context.c
     ${SRC_DIR}/Python/fileutils.c
+    ${SRC_DIR}/Python/hamt.c
+    ${SRC_DIR}/Python/pathconfig.c
     ${SRC_DIR}/Python/pyhash.c
     ${SRC_DIR}/Python/pylifecycle.c
     ${SRC_DIR}/Python/pystrhex.c
@@ -400,7 +412,7 @@ if(WIN32 AND IS_PY3)
 endif()
 
 set(LIBPYTHON_FROZEN_SOURCES )
-if(IS_PY3)
+if(IS_PY3 AND NOT WINDOWS_STORE)
 
 # Build _freeze_importlib executable
 add_executable(_freeze_importlib
@@ -439,6 +439,7 @@ add_custom_target(freeze_modules DEPENDS ${LIBPYTHON_FROZEN_SOURCES})
 
 endif()
 
+if(NOT WINDOWS_STORE)
 # Build pgen executable
 set(PGEN2_SOURCES
     ${SRC_DIR}/Parser/parsetok.c
@@ -460,6 +461,7 @@ add_executable(pgen
 if(builtin_compile_definitions_without_py_limited_api)
   target_compile_definitions(pgen PUBLIC ${builtin_compile_definitions_without_py_limited_api})
 endif()
+endif()
 
 # Collect libpython sources
 set(LIBPYTHON_SOURCES
@@ -608,7 +610,7 @@ if(NOT BUILD_LIBPYTHON_SHARED)
     set_target_properties(libpython-static PROPERTIES
         ARCHIVE_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/${LIBPYTHON_STATIC_ARCHIVEDIR}
     )
-    if(INSTALL_DEVELOPMENT)
+    if(INSTALL_DEVELOPMENT AND OFF)
         install(TARGETS libpython-static
             ARCHIVE DESTINATION ${PYTHONHOME}/config/
             COMPONENT Development)
-- 
2.20.1.windows.1

